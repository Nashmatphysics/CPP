/*2018/06/18
scanf_and_printf
*/
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <windows.h>

/**************************printf(), scanf()的返回值********************************/
int main1(void)
{
    //printf()返回打印的字节数
    int i, j, k;
    i = printf("%d", 123);
    putchar('\n');
    printf("i: %d\n", i);//此处输出结果为3,如果7行的printf有\n,则i为4

    j = printf("aaa");
    putchar('\t');
    printf("j: %d\n", j);//3, 说明跟\0没有关系.

    k = scanf("%d", &i);
    printf("%d\n", k);//此处输出结果为1, scanf返回读取的项目数, 失败返回0

    //getchar();
    system("pause");
    return 0;
    //在要求严格的程序中,应该判断每次调用scanf或printf的返回只,从而了解程序运行中是否存在问题
}

/***********************************格式化输出*************************************/
int main2(void)
{
    //printf: %[flags][width][.prec][hlL]type
    //[flag]
    printf("%10d\n", 123);//默认表示右对齐, 数字代表输出总共所占字符数
    //若这个数字小于实际所占字符数, 则按实际字符数显示 
    printf("%-10d\n", 123);//"-"表示左对齐 
    printf("%+10d\n", 123);//"+" 输出的值前加+
    printf("%+-10d\n", 123);//+放在-的左边或右边不影响+和-的作用，
    //如果输出的值是一个负数，则+自动隐藏
    printf("%010d\n", 123);//"0"输出值前面的空格由0填充 
    //不能和-结合，因为左对齐就没有位置给0填充了
    //width或prec
    printf("%f\n", 123); //将整型用%f输出,不会发生强制类型转换, 而是直接为0.0000...,或直接报错 
    printf("%Lf", 123.0);//long double用的是Lf, float和double使用的都是f 
    printf("%9.2f\n", 123.0);//输出一共占9个字符(包括小数点), 小数点后有2位
    printf("%*d\n", 6, 123);//*表示输出所占的字符数为参数表中第一个参数的值.
    printf("%*.*f\n", 7, 3, 123.0);
    //*相当于宏, 而参数表中的第一个参数可以用一个变量来表示,这样就给长度指定带来了很大的灵活性 
    //如:printf("%*d\n", len, 123);
    printf("%.*f\n", 3, 13.0); //.*表示小数点后的位数为参数表中第一个参数的值
    printf("%.6f\n", 123.0);//.number表示小数点后的位数, 也可写成 printf("%0.6f\n", 123.0);
    printf("%.3s\n", "nash");//用在字符串上表示从左到右截取n个字符显示 ,即nas
    //使用3s\n无效 
    //类型修饰
    //int
    /*
hh:单个字节 ,新版编译器省略了此功能.
h:short
l:long
ll:long long
L: long double
*/
    printf("%hhd\n", 1245);//将整数以单个字节长度输出, 即最大长度为8位2进制,如果超出则高位溢出,
    //新版编译器省略了此功能, 输出结果仍为1245. 
    printf("%lf\n", 1245.0);
    ///////////////////////////////////////////////////////////	
    //格式字符(见表格)
    int num;
    printf("%d %n\n", 12345, &num); //%n表示将%n前面输出的字符数量(包括空格)的值赋值给变量num,VS中存在问题 
    printf("%d\n", num);
    //////////////////////////////////////////////////////
    //printf("Jamsa%n's 1001 C & C++ Tips%n\n", &first_count, &second_count);//%n只相当于一个书签, 并不作为计数对象 ,如下输出结果 
    //printf("First count %d Second count %d\n", first_count, second_count);
    /*
       输出结果
       Jamsa's 1001 C & C++ Tips
       First count 5 Second count 25
       */
    //////////////////////////////////////////////////////

    //scanf: %[flag]type(见表格)
    int a, b;
    scanf("%*d %d", &a, &b);//*表示跳过读取输入的值(不读),而将第二个%d读到给a, b是没有输入值的! 
    //注意:有效读取的输入才是一一对应的关系,所以此处是a获取%d的值, 而不是b获取%d,此处易错 
    scanf("%*d %d", &a);//a读到的是%d, %*d被跳过 
    printf("a=%d, b=%d\n", a, b);
    int m;
    scanf("%i", &m);//以用户指定的进制读进来, 例如输入0X123,表示16进制输入123,即为10进制的291 
    printf("%i", 0x12);//以用户指定的进制输出 
    printf("%%\n");//2个百分号输出%
    puts("hello,world");//单纯输出字符串函数, 和getchar对应 
    return 0;
    /*
       输出结果:
       =================
       123
       123
       +123
       +123
       0000000123
       0.000000
       123.000000   123.00
       123
       123.000
       13.000
       123.000000
       nas
       1245
       1245.000000
       12345 0
       ====================
       总结:
       printf对应参数不够的情况下, 多余的格式输出符放进去的是垃圾值*/
}

/********************************%x %X %#x %#X %o %#o %e的用法**************************************/
int main(void)
{
	/*
    int x = 47;  
    printf("%x\n", x);  //输出结果是:  2f
    printf("%X\n", x);	//输出结果是:  2F
    printf("%#X\n", x);	//输出结果是:  0X2F  %#X推荐使用
    printf("%#x\n", x);	//输出结果是:  0x2f
    printf("%o\n", x);
    printf("%#o\n", x);
	*/

	int a = 20;
	printf("%e\n", e);//以指数形式输出

    //%o（字母o）:以8进制输出
    //%#o:以8进制输出，前面加0（零）
    //%o,%x都是无符号输出,即第一位一开始就参与数值运算,如果为负数, 则自动转换为无符号数输出
    /*
       2f
       2F
       0X2F
       0x2f
       57
       057
       */
    system("pause");
    return 0;
}
/***********************************%p地址打印*************************************/

int main4(void)
{
    int i = 5;
    printf("%x\n", i);
    printf("%p\n", i);
    //所谓%p, 就是以16进制0x形式打印指定变量的值, 而不是变量本身的地址.

    system("pause");
    return 0;
}

/***********************************缓冲区换行问题*************************************/
int main5(void)
{
    //输入数据回车后, 数据会被接收, 但回车还在缓冲区中等待接收.
    int i = 0;
    scanf("%d", &i);
    getchar();
    //scanf()会将开头是回车的字符抛弃, 从第一个不是回车的字符开始接收
    scanf("%d", &i);
    char a[128] = {0};
    scanf("%s", a);
    system("pause");
    return 0;
    //同样的道理, 未被scanf接收的其他字符也在缓冲区中.
}

/***********************************scanf内存访问越界*************************************/
int main6(void)
{
    char buf[5] = {0};
    scanf("%s", buf);//scanf()在读取数据时不检查边界，所以可能会造成内存访问越界.
    printf("%s", buf);
    /*
       nashnashnash
       nashnashnash请按任意键继续. . .
       */
    system("pause");
    return 0;
    //此时程序可能崩溃, 也可能不崩溃.
}
/*************************************处理scanf输入数字时的非法输入***********************************/
int main7(void)
{
	long long a = 0;
	char arry[50] = { '\0' };
	scanf("%s", arry);
	getchar();
	for (int i = 0; ; ++i)
	{

		if (arry[i] == '\0')
		{
			a = atoi(arry);
			printf("a = %ld\n", a);
			break;
		}

		if (!((arry[i] <= 57) && (arry[i] >= 48)))
		{
			printf("你输入的有误!\n");
			break;
		}

	}

	return 0;
}
/*
由于scanf对于"123m"这样的输入并不会报错, 也不会返回0, 所以必须在程序中加以设置才行.
*/
